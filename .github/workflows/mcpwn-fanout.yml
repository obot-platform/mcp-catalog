name: Mcpwn Fan-out (dispatch one run per YAML)
run-name: ${{ inputs.workflow_name || 'Mcpwn Scan' }} - Fan-out
on:
  workflow_dispatch:
    inputs:
      workflow_name:
        description: "Custom workflow name (optional)"
        required: false
        type: string
        default: "Mcpwn Scan"

permissions:
  contents: read
  actions: write

jobs:
  dispatch:
    name: Dispatch worker runs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Build targets list (matrix.json)
        id: build
        run: |
          set -euo pipefail

          all_files=$(find . -name "*.yaml" -type f | jq -R -s -c 'split("\n") | map(select(length > 0))')
          file_configs="[]"

          if [ "$all_files" = "[]" ] || [ -z "$all_files" ]; then
            echo "[]" > matrix.json
          else
            while read -r file; do
              file="${file#./}"

              if [ -f "$file" ]; then
                containerized_config=$(yq eval '.containerizedConfig' "$file" -o=json -I=0)

                if [ "$containerized_config" != "null" ]; then
                  env_config=$(yq eval '.env' "$file" -o=json -I=0)

                  entry=$(jq -n \
                    --arg file "$file" \
                    --argjson containerized "$containerized_config" \
                    --argjson env "$env_config" \
                    '{file: $file, containerizedConfig: $containerized, env: $env}')

                  file_configs=$(echo "$file_configs" | jq --argjson entry "$entry" '. += [$entry]')
                fi
              fi
            done < <(echo "$all_files" | jq -r '.[]')

            echo "$file_configs" | jq -c . > matrix.json
          fi

          echo "count=$(jq length matrix.json)" >> "$GITHUB_OUTPUT"
          echo "Targets: $(jq length matrix.json)"

      - name: Dispatch one worker run per target
        if: ${{ steps.build.outputs.count != '0' }}
        uses: actions/github-script@v8
        env:
          WORKFLOW_NAME: ${{ inputs.workflow_name }}
        with:
          script: |
            const fs = require('fs');

            const targets = JSON.parse(fs.readFileSync('matrix.json', 'utf8'));
            core.info(`Dispatching ${targets.length} worker run(s)...`);

            // Find the workflow by path, then dispatch by numeric ID
            const workflows = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const workerPath = '.github/workflows/mcpwn-worker.yml';
            const worker = workflows.data.workflows.find(w => w.path === workerPath);

            if (!worker) {
              core.setFailed(`Cannot find workflow at ${workerPath}. Check the file name/path on the branch.`);
              return;
            }

            // IMPORTANT: ref must be a branch or tag name (NOT a SHA)
            // For workflow_dispatch runs, this will typically be 'main' or whatever branch you selected in the UI.
            const refName = (process.env.GITHUB_REF_NAME || '').trim();
            if (!refName) {
              core.setFailed(`GITHUB_REF_NAME is empty. Ref must be a branch or tag name.`);
              return;
            }

            // Retry helper function
            async function retryDispatch(fn, maxRetries = 3, delayMs = 1000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  if (attempt === maxRetries) {
                    throw error;
                  }
                  core.warning(`Attempt ${attempt} failed: ${error.message}. Retrying in ${delayMs}ms...`);
                  await new Promise(resolve => setTimeout(resolve, delayMs));
                  delayMs *= 2; // Exponential backoff
                }
              }
            }

            for (const t of targets) {
              const argsJson = JSON.stringify(t.containerizedConfig?.args ?? []);
              const envJson  = JSON.stringify(t.env ?? {});

              const argsB64 = Buffer.from(argsJson, 'utf8').toString('base64');
              const envB64  = Buffer.from(envJson, 'utf8').toString('base64');

              core.info(`Dispatching: ${t.file} on ref ${refName}`);

              await retryDispatch(async () => {
                return await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: worker.id,
                  ref: refName,
                  inputs: {
                    file: t.file,
                    image: String(t.containerizedConfig.image),
                    port: String(t.containerizedConfig.port),
                    args_b64: argsB64,
                    env_b64: envB64,
                    workflow_name: process.env.WORKFLOW_NAME || 'Mcpwn Scan'
                  }
                });
              });
            }

      - name: No targets
        if: ${{ steps.build.outputs.count == '0' }}
        run: echo "No YAML files with containerizedConfig found."
